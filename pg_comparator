#! /usr/local/bin/perl -w
#
# $Id: pg_comparator 190 2004-08-25 09:52:37Z coelho $
#
# HELP 1: pg_comparator --man
# HELP 2: pod2text pg_comparator
# HELP 3: read pod stuff bellow with your favorite viewer
#

=head1 NAME

B<pg_comparator> - network and time efficient table content comparison.

=head1 SYNOPSIS

B<pg_comparator> [options as B<--help> B<--option> B<--man>] conn1 conn2

=head1 DESCRIPTION

This script performs a network and time efficient comparison of two
possibly large tables on two servers. It makes only sense to use it
if the expected differences are small.

The implementation is quite generic: multi-column keys, no assumption
of data types other that they can be cast to text, subset of columns
can be used for the comparison, handling of null values...

=head1 OPTIONS

Options allow to request help or to adjust some internal parameters.
Short one-letter options are also available, usually with the first letter
of the option name.

=over 4

=item B<--aggregate=xor>

Aggregation function to be used for summaries.
Must operate on the result of the checksum function.

=item B<--ask-pass>

Ask for passwords interactively.

=item B<--checksum=cksum4>

Checksum function to be used. The quality of this function in term
of bit-spreading and uniformity is important for the quality of the
results. A poor function might miss differences because of collisions
or result in a more costly search. Cryptographic hash functions such as 
MD5 or SHA1 are a good choice.

=item B<--factor=128>

Folding factor: the number of rows grouped together at each stage.
Default chosen after some basic tests on medium-size cases.

=item B<--help>

Show short help.

=item B<--man>

Show manual page.

=item B<--max=32>

Maximum search effort, search will stop if above: it gives up if a 
single query at any level involves more than this many differences. 
Use 0 for no limit.

=item B<--null="null_string(%s,'null')">

String processing template to take care of null values.
If you set --null='%s', null values are set as they appear,
which might damage the results in null columns are used because 
multi-column checksums will all be 0.

=item B<--option>

Show option summary.

=item B<--prefix=cmp>

Name prefix for comparison tables. May be schema-qualified.

=item B<--separator=:>

Separator string when concatenating columns.

=item B<--source='DBI:Pg:dbname=%b;host=%h;port=%p;'>

DBI source template. Changing this might allow to use this command 
with another type of database, as the SQL used is quite standard.
Tags are interpreted as follow: %b is base, %h is host, %p is port, %u 
is login.

=item B<--temporary --notemporary>

Whether to use temporary tables. Default is to use.
If you don't, the tables are kept at the end, so they will have
to be deleted by hand.

=item B<--verbose>

Be verbose about what is happening. The more you ask, the more verbose.

=back

=head1 ARGUMENTS

The two arguments describe database connections with the following syntax,
where square brackets denote optionnal parts:

  [login[:pass]@][host[:port]][[/base]/[schema.]table[?[key:]cols]]

=over 4

=item B<login>

Login to use when connecting to database. Default is username.

=item B<pass>

Password to use when connecting to database. Default is none.

=item B<host>

Hostname to connect to. Default is localhost.

=item B<port>

Tcp-ip port to connect to. Default is 5432.

=item B<base>

Database catalog to connect to. Default is username.

=item B<schema.table>

The possibly schema-qualified table to use for comparison.
Default is same as first connection.

=item B<keys>

Comma-separated list of key columns. Default is same as first connection.

=item B<cols>

Comma-separated list of columns to compare. Default is same as first 
connection.

=back

=head1 OUTPUT

The output of the command consists of lines describing the differences
found between the two tables. They are expressed in term of insertions,
updates or deletes and of tuple keys.

=over 4

=item B<UPDATE k>

Key "k" tuple was updated between table 1 to 2.
The tuple exists in both tables with different values.

=item B<DELETE k>

Key "k" tuple was deleted in table 2, assuming table 1 as the reference.
The tuple only appears in table 1.

=item B<INSERT k>

Key "k" tuple was inserted into table 2, assuming table 1 as the reference.
The tuple only appears in table 2.

=back

=head1 DEPENDENCES

Three support functions are needed on the database:

=over 2

=item 1

The null_string function takes care of NULL values in columns.
It may be changed with the --null option.

A suitable implementation is available for PostgreSQL and can be loaded
into the server by processing "share/contrib/null_string.sql".

=item 2

A checksum function must be used to reduce and distribute key
and columns values. 
It may be changed with the --checksum option.

Three suitable implementations are available for PostgreSQL and can be loaded
into the server by processing "share/contrib/checksum.sql".
The three functions cksum2, cksum4 and cksum8 differ on the size
of the resulting checksum expressed in bytes. The default is to use
the cksum4 version.

=item 3

An aggregate function is used to summarize checksums for a range of rows. 
It must operate on the result of the checksum function.
It may be changed with the --aggregate option.

Suitable implementations of a xor aggregate are available for
PostgreSQL and can be loaded into the server by processing 
"share/contrib/xor_aggregate.sql".

=back

Moreover several perl modules are useful to run this script:

    Getopt::Long for option management.
    DBI and DBD::Pg to connect to PostgreSQL.
    Term::ReadPassword if ask-pass option is triggered.
    Pod::Usage if doc self-extraction (--man --opt --help) is required.

=head1 EXAMPLES

Compare tables calvin and hobbes in default database on localhost, 
with key "id" and columns "c1" and "c2":

    ./pg_comparator /calvin?id:c1,c2 /hobbes

Compare tables calvin in default database on localhost and the same
table in default database on sablons, with key "id" and column "data":

    ./pg_comparator localhost/calvin?id:data sablons

=head1 ANALYSIS

Let n be the number of rows, r the row size, f the folding factor
and k the number of differences to be detected. Then ISTM that:

=over 2

=item 1

The network volume complexity is better than k*f*ceil(log(n)/log(f)).
It is independent of r, the lower f the better, and you want k<<n.

=item 2

The maximum number of requests is 6+2*ceil(log(n)/log(f)).
The minimum is 6+ceil(log(n)/log(f)) if the two tables are equals.

=item 3

The disk I/O traffic complexity on the tables is n*r+n*ln(n)*(f/(f-1)).
Here a not too small f is better, as it reduces both the number of 
requests and of disk I/Os; 

=back

The choice of f is indeed a tradeoff.

=head1 REFERENCES

This script and algorithm was somehow inspired by:

=over 2

"Taming the Distributed Database Problem: A Case Study Using MySQL"
by Giuseppe Maxia in "Sys Admin" vol 13 num 8, Aug 2004, pp 29-40.

=back

In the above paper, three algorithms are presented. 
The first one compares two tables with a checksum technique.
The second one finds UPDATE or INSERT differences based on a 2-level 
(checksum and summary) table hierarchy. The algorithm is asymetrical,
as different queries are performed on the two tables to be compared.
It seems that the network traffic volume is in k*(f+(n/f)+r),
that it has a probabilistically-buggy merge procedure, and
that it makes assumptions about the distribution of key values.
The third algorithm looks for DELETE differences based on counting,
with the implicit assumption that there are only delete differences.

The algorithm used here implements all three tasks. It is fully symetrical.
It finds UPDATE, DELETE and INSERT between the two tables. 
The checksum and summary hierarchical level idea is reused and generalized
so as to reduce the algorithmic complexity.

From the implementation standpoint, the script is as parametric 
as possible thru many options, and makes as few assumptions 
as possible about table structures, types and values.

=head1 SEE ALSO

Some products implement such features, as for instance:
    http://www.programurl.com/software/sql-server-comparison.htm
    http://www.dbbalance.com/db_comparison.htm
    http://www.dkgas.com/dbdiff.htm

=head1 BUGS

All softwares have bugs. This is a software, hence it must have bugs.
Reporting bugs is good practice, so tell me if you find one.

=head1 VERSION

$Revision: 190 $ see http://www.coelho.net/pg_comparator/

=head1 COPYRIGHT

Copyright (c) 2004, Fabien Coelho <fabien at coelho dot net>

This softwere is distributed under the terms of the BSD Licence. 
Basically, you can do whatever you want, but you have to keep
the license... and I'm not responsible for any consequences. 
Beware, you may lose your data or your hairs because of this software!
See the LICENSE file enclosed with the distribution for details.

=cut

use strict; # I don't like perl;-)
use Getopt::Long;
use DBI;

# various option defaults
my ($factor, $temp, $ask_pass, $verb, $max_report) = (128, 1, 0, 0, 32);
my ($cksum, $agg, $prefix, $sep) = ('cksum4', 'xor', 'cmp', ':');
my $source = 'DBI:Pg:dbname=%b;host=%h;port=%p;';
my $null = "null_string(%s,'null')";

# self extracting help
# usage(verbosity, exit value, message)
sub usage($$$)
{
    my ($verbose,$stat,$msg) = @_;
    print STDERR "ERROR: $msg\n" if $msg;
    require Pod::Usage;
    Pod::Usage::pod2usage(-verbose => $verbose, -exitval => $stat);
}

# parse a connection string... or many options instead?
# could we directly ask for the DBI connection string?
# ($u,$w,$h,$p,$b,$t,$k,$c) = parse_conn("connection-string")
# globals: %ENV, $verb
sub parse_conn($)
{
    my $c = shift;
    my $saved = $c;
    my ($user,$pass,$host,$port,$base,$tabl,$keys,$cols) = # set defaults
	($ENV{USER}, '', 'localhost', 5432, $ENV{USER}, '', '', '');

    # pretty rough...
    ($user, $pass) = ($1, $3) if $c =~ s/^([\w]+)(:([^\@]*))?\@//i;
    ($host, $port) = ($1, $3) if $c =~ s/^([\w]+)(:(\d+))?//i;
    ($base, $tabl) = ($2, $3) if $c =~ s,^/(\w+)/([\w.]+),,i;
    $tabl = $1 if not $tabl and $c =~ s,^/([\w.]+),,i;
    ($keys, $cols) = ($2, $3) if $tabl and $c =~ s/^\?(([\w,]+):)?([\w,]+)//i;

    my @res = ($user,$pass,$host,$port,$base,$tabl,$keys,$cols);
    die "parse error on '$saved' at '$c'\n@res\n" if $c;
    print "connection parameters: @res\n" if $verb>1;
    return @res;
}

# $dbh = conn($base,$host,$port,$user,$pass)
# globals: $source $verb
sub conn($$$$$)
{
    my ($b,$h,$p,$u,$w,$t) = @_;
    my $s = $source;
    $s =~ s/\%b/$b/g;  $s =~ s/\%h/$h/g;  $s =~ s/\%p/$p/g;  $s =~ s/\%u/$u/g;
    my $dbh = DBI->connect($s, $u, $w, { RaiseError => 1, PrintError => 0 });
    print "# connected to $u\@$h:$p/$b\n" if $verb;
    return $dbh;
}

# $number_of_rows = count($dbh,$table)
sub count($$)
{
    my ($dbh,$table) = @_;
    return $dbh->selectrow_array("SELECT COUNT(*) FROM $table");
}

# @l = null_string(@column_names)
# globals: $null
sub null_string(@)
{
    for my $s (@_) {
	my $n = $null;
	$n =~ s/\%s/$s/g;
	$s = $n;
    }
    return @_;
}

# returns an sql concatenation of fields
# $sql = concat($string_of_comma_separated_fields)
# globals: $sep ($null)
sub concat($)
{
    return join("||'$sep'||",null_string(split(/,/,shift)));
}

# $count = compute_cheksum($dbh,$table,$keys,$cols,$name)
# globals: $temp $cksum $verb ($sep $null)
sub compute_cheksum($$$$$)
{
    my ($dbh,$table,$keys,$cols,$name) = @_;
    print "building checksum table ${name}0\n" if $verb>1;
    $dbh->do("CREATE $temp TABLE ${name}0 AS " .
	     "SELECT " . concat($keys) . " AS id," .
	     # ABS(idc) because of sql MOD may have negative remainder
	     # idc needed to avoid assumptions about keys...
	     " ABS($cksum(" . concat($keys) . ")) AS idc," .
	     " $cksum(" . concat($cols) . ") AS cks " . # COUNT+SUM?
	     "FROM $table");
    return count($dbh, "${name}0");
}

# compute_summaries($dbh, $name, @modules)
# globals: $verb $temp $agg
sub compute_summaries($$@)
{
    my ($dbh,$name,@modules) = @_;
    # compute cascade of summary tables
    for my $n (1 .. @modules-1) {
	print "building summary table ${name}$n ($modules[$n])\n" if $verb>1;
	$dbh->do("CREATE $temp TABLE ${name}$n AS " .
		 "SELECT MOD(idc,$modules[$n]) AS idc, $agg(cks) AS cks " .
		 "FROM ${name}" . ($n-1) . " " .
		 "GROUP BY MOD(idc,$modules[$n]) " .
		 "ORDER BY idc ASC");
    }
}

# get info for investigated a list of idc (hopefully not too long)
# $sth = selidc($dbh,$table,$module,$get_id,@idc)
sub selidc($$$$@)
{
    my ($dbh,$table,$module,$get_id,@idc) = @_;
    my $sth = 
	$dbh->prepare("SELECT idc, cks" . ($get_id? ", id ": " ") .
		      "FROM $table " .
		      "WHERE MOD(idc,$module) IN (" . join(',', @idc) . ") " .
		      "ORDER BY idc ASC");
    $sth->execute();
    return $sth;
}

# compute differences by climbing up the tree, output result on the fly.
# differences($dbh1, $dbh2, $name1, $name2, @modules)
# globals: $max_report $verb
sub differences($$$$@)
{
    my ($dbh1, $dbh2, $name1, $name2, @modules) = @_;
    my $n = @modules-1;
    my $module = 1; # module of previous table
    my @idc = (0);
    my @next_idc = ();

    while ($n>=0 and @idc)
    {
	if ($max_report && @idc>$max_report) {
	    print "giving up at level $n: too many differences.\n" .
		"\tadjust max option (current is $max_report) to proceed.\n" .
		"\tidc list length is " . scalar @idc . ": @idc\n";
	    return;
	}

	print "investigating @idc at level $n\n" if $verb>1;
	my $s1 = selidc($dbh1, ${name1}.$n, $module, !$n, @idc);
	my $s2 = selidc($dbh2, ${name2}.$n, $module, !$n, @idc);
	my (@r1,@r2);
	
	# let us merge the two ordered select
	while (1)
	{
	    @r1 = $s1->fetchrow_array() unless @r1 or not $s1->{Active};
	    @r2 = $s2->fetchrow_array() unless @r2 or not $s2->{Active};
	    last unless @r1 or @r2;
	    
	    if (@r1 && @r2 && $r1[0]==$r2[0]) { # matching idc
		if ($r1[1] != $r2[1]) { # non matching checksums
		    push @next_idc, $r1[0]; # to be investigated...
		    print "UPDATE $r1[2]\n" if not $n;
		}
		@r1 = @r2 = ();
	    }
	    elsif ((!@r2) || (@r1 && $r1[0]<$r2[0])) { # more idc in table 1
		print "DELETE ", $n? "$r1[0] at level $n": "$r1[2]", "\n";
		@r1 = ();
	    } 
	    elsif ((!@r1) || (@r2 && $r1[0]>$r2[0])) { # more idc in table 2
		print "INSERT ", $n? "$r2[0] at level $n": "$r2[2]", "\n";
		@r2 = ();
	    }
	}
	$s1->finish(); 	$s2->finish();
	$n--; # next table
	$module = pop @modules; # next module
	@idc = @next_idc; # idcs to be investigated on next round
	@next_idc = ();
    }
}

# option management
GetOptions("manual|man|m" => sub { usage(2, 0, ''); },
           "options|option|o" => sub { usage(1, 0, ''); },
           "help|h" => sub { usage(0, 0, ''); },
	   "verbose|v+" => \$verb,
	   "checksum-function|cksum|c=s" => \$cksum,
	   "aggregate-function|a=s" => \$agg,
	   "factor|f=i" => \$factor,
	   "maximum|x=i" => \$max_report,
	   "null|n=s" => \$null,
	   "prefix|p=s" => \$prefix,
	   "separator|s=s" => \$sep,
	   "source|u=s" => \$source,
	   "temporary|tmp|t!" => \$temp,
	   "ask-pass|ap!" => \$ask_pass) or die "$! (try $0 --help)";

# fix --temp or --notemp option
$temp = $temp? 'TEMPORARY': '';

# factor MUST BE a power of 2 (easier to look for them)
$factor = 2**int(log($factor)/log(2));
$factor = 2 if $factor<2;

# intermediate table names
my ($name1,$name2) = ("${prefix}_1_", "${prefix}_2_");

# argument management
usage(0,0,'expecting 2 arguments') unless @ARGV == 2;
my ($u1,$w1,$h1,$p1,$b1,$t1,$k1,$c1) = parse_conn(shift);
my ($u2,$w2,$h2,$p2,$b2,$t2,$k2,$c2) = parse_conn(shift);

# fix some default values
$t2 = $t1 unless $t1;  $k2 = $k1 unless $k2;  $c2 = $c1 unless $c2;

if ($ask_pass) {
    require Term::ReadPassword;
    $w1 = Term::ReadPassword::read_password('connection 1 password> ');
    $w2 = Term::ReadPassword::read_password('connection 2 password> ');
}

# let us work...

print "# connecting to database servers...\n" if $verb;
my $dbh1 = conn($b1,$h1,$p1,$u1,$p1);
my $dbh2 = conn($b2,$h2,$p2,$u2,$p2);

print "# building checksum tables and counting rows...\n" if $verb;
my $count1 = compute_cheksum($dbh1, $t1, $k1, $c1, $name1);
my $count2 = compute_cheksum($dbh2, $t2, $k2, $c2, $name2);

print "# computing size and modules after folding factor...\n" if $verb;
my $size = $count1>$count2? $count1: $count2; # max?
my @modules = ($size);
my $module = 2**int(log($size/$factor)/log(2));
while ($module>1) {
    push @modules, $module;
    $module = int($module/$factor);
}
push @modules, 1;

print "# building summary tables...\n" if $verb;
compute_summaries($dbh1, $name1, @modules);
compute_summaries($dbh2, $name2, @modules);

print "# looking for differences...\n" if $verb;
differences($dbh1,$dbh2,$name1,$name2,@modules);

print "# done...\n" if $verb; 
$dbh1->disconnect();  $dbh2->disconnect();
